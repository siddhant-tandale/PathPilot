"""
Author: Sid Tandale
Program: Pathfinding Module
Description: Implements A* pathfinding algorithm with diagonal movement and collision checking.
"""

# Imports
import heapq
import numpy as np
import math

# Collision checking function
def check_collision(x, y, grid):
    """
    Checks if point (x, y) is outside the grid or inside an obstacle.
    Returns True if collision detected, else False.
    """
    
    # Get grid dimensions
    rows, cols = grid.shape

    # Check boundaries and obstacles
    if x < 0 or y < 0 or x >= cols or y >= rows:
        print("Error: Point outside map.")
        return True
    if grid[y, x] == 1:
        print("Error: Point inside obstacle.")
        return True
    return False

# Neighbor retrieval function
def get_neighbors(x, y):
    """
    Returns all 8 neighboring cells (including diagonals).
    """
    return [
        (-1, 0), (1, 0), (0, -1), (0, 1),
        (-1, -1), (-1, 1), (1, -1), (1, 1)
    ]

# A* pathfinding function
def a_star(start, goal, grid):
    """
    Implements the A* pathfinding algorithm with diagonal movement.
    start, goal: (x, y) tuples
    grid: 2D numpy array (0 = free, 1 = obstacle)
    Returns list of (x, y) tuples representing the path, or empty list if no path found.
    """

    # Initialize open set and cost dictionaries
    # Start of code generated by ChatGPT
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g = {start: 0}
    # End of code generated by ChatGPT

    # Main A* loop
    while open_set:
        # Get node in open set with lowest f = g + h
        # Generated by ChatGPT
        _, current = heapq.heappop(open_set)

        # Check if goal reached
        if current == goal:
            path = [current]
            while current in came_from:
                current = came_from[current]
                path.append(current)
            return list(reversed(path))

        # Explore neighbors
        cx, cy = current
        for dx, dy in get_neighbors(cx, cy):
            nx, ny = cx + dx, cy + dy

            if check_collision(nx, ny, grid):
                continue

            # Calculate costs
            step_cost = math.sqrt(2) if dx != 0 and dy != 0 else 1
            new_g = g[current] + step_cost

            # Update costs and paths if better path found
            if (nx, ny) not in g or new_g < g[(nx, ny)]:
                g[(nx, ny)] = new_g

                # Heuristic (Octile distance)
                hx = abs(goal[0] - nx)
                hy = abs(goal[1] - ny)
                h = (math.sqrt(2) * min(hx, hy)) + (max(hx, hy) - min(hx, hy))

                # Total cost
                f = new_g + h
                heapq.heappush(open_set, (f, (nx, ny)))
                came_from[(nx, ny)] = current

    print("No path found.")
    return []